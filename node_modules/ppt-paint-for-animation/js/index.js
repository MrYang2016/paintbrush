import '../style/myStyle.scss';
import Paintbrush from './paintbrush';
import * as UTIL from './util';

class PPTH5 {
  constructor({
    content = '#content',
    sendMessage = () => { },
    hasPaintbrush = true,
    canEditPaint = false,
    isAnimate,
    autoId,
    pptType
  } = {}) {
    this.contentDiv = typeof content === 'string' ? document.querySelector(content) : content;
    if (!this.contentDiv) throw new Error('页面未加载完dom元素或者元素不存在');
    this.contentDiv.setAttribute('style', 'height: 100%;width: 100%;position: absolute;background-color: #393842;text-align: center;');

    this.content = UTIL.createElement('div', { id: 'pptAndPaintDiv' });
    const loadingHtml = '<div id="loading"><div class="line-spin-fade-loader"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>';
    this.content.innerHTML = loadingHtml;
    this.contentDiv.appendChild(this.content);

    this.sendMessage = sendMessage;
    this.hasPaintbrush = hasPaintbrush;
    this.canEditPaint = canEditPaint;
    this.parentUrl = (window.location != window.parent.location)
      ? document.referrer
      : document.location.href;
    this.iframe = null;
    this.pptImg = null;
    this.pageType = 'page';
    this.currentAutoId;
    this.paintData = null;
    this.drawDataKeyUsePage = {};
    this.prop = 1;
    this.preTime = 0;
    this.isListen = false;
    this.isRedraw = true;
    this.isAnimate = isAnimate;
    this.pptType = pptType;
    this.autoId = autoId;
    this.init();
    UTIL.initREM();
  }

  init(id) {
    const {
      isAnimate = this.isAnimate,
      autoId = this.autoId,
      pptType = this.pptType
    } = UTIL.getAddressVal();
    if (!(autoId || id)) return;

    this.isAnimation = isAnimate !== 'false';
    this.operation = null;
    this.pageNum = 0;
    this.currentPageNum = 0;
    this.operationHistoryFun = {};

    // 请求ppt相关数据
    const isNew = pptType === 'new';
    const pptID = id || autoId;
    const msgUrl = isNew ? `//doc.polyv.net/get/oneJson?autoId=${pptID}` : `//doc-2.polyv.net/data/${pptID}.json`;
    this.currentAutoId = pptID;

    const { style } = this._getSize();
    this.content.setAttribute('style', style);
    const { isIE, version } = UTIL.browserType();
    const isIE9 = isIE && version < 10;
    this.initPaintBrush();
    this.paintbrushCtrl.autoId = pptID;

    this._listen();

    return UTIL.ajax({ url: msgUrl }).then(result => {
      const { code, data } = result;
      if (code !== 200) return false;
      const pptData = UTIL.parseJson(data);
      const getPPTObj = isNew ? UTIL.parseJson(pptData.jsonContent) : pptData.convertFileJson;
      const { htmlUrl, images, imageCount } = getPPTObj;
      this.pageNum = imageCount;

      this.isAnimation = this.isAnimation && pptData.convertType === 'animate' && !isIE9;

      this.operation = this.isAnimation
        ? this.animationControl(this.content, htmlUrl)
        : this.staticPhotoControl(this.content, images);

      this.content.appendChild(this._getBtns());

      return true;

    }).catch(console.error);
  }

  initPaintBrush() {
    const { width, height } = this._getSize();
    // 画笔初始化
    if (this.hasPaintbrush && !this.paintbrushCtrl) {
      let pptDiv;
      const oldPaint = document.querySelector('#paintbrush');
      if (oldPaint) {
        oldPaint.innerHTML = '';
        pptDiv = oldPaint;
      } else {
        pptDiv = UTIL.createElement('div', { id: 'paintbrush' });
        this.content.appendChild(pptDiv);
      }
      this.paintbrushCtrl = new Paintbrush(pptDiv, {
        width,
        height,
        canEdit: this.canEditPaint
      });
      this.paintbrushCtrl.subResize((prop) => {
        if (prop !== this.prop) this._resize(prop);
      });
      this._listen();
    }
  }

  _listen() {
    if (this.isListen) return;
    this.isListen = true;
    UTIL.addHandler(window, 'message', event => {
      this.listenMsgCallback(event.data);
    });
    UTIL.addHandler(window, 'resize', () => {
      this._resize();
    });
  }

  _getBtns() {
    const btns = UTIL.createElement('div', { class: 'btns' });
    btns.innerHTML = '<div id="button-prev" class="btn btn-prev"><div class="icon" id="btn-prev"></div></div><div id="button-next" class="btn btn-next"><div class="icon" id="btn-next"></div></div>';
    return btns;
  }

  _resize(prop) {
    if (!this.paintbrushCtrl) return;
    const { width, height, style } = this._getSize(prop);
    this.content.setAttribute('style', style);
    this.paintbrushCtrl.setMeasurement({
      w: width,
      h: height,
      pageId: this.currentPageNum,
      pageType: this.pageType,
      isRedraw: this.isRedraw
    });
  }

  _getSize(p) {
    const WHProp = this.contentDiv.clientWidth / this.contentDiv.clientHeight;
    let width = this.contentDiv.clientWidth;
    let height = this.contentDiv.clientHeight;
    const prop = this.prop = p || this.prop || (4 / 3);
    if (WHProp > prop) {
      width = prop * height;
    } else if (WHProp < prop) {
      height = width / prop;
    }
    return { width, height, style: `position:absolute;left:50%;top:50%;height:${height}px;width:${width}px;margin-left:-${width / 2}px;margin-top:-${height / 2}px` };
  }

  animationControl(content, showUrl) {
    if (this.iframe) {
      this.iframe.setAttribute('src', showUrl);
    } else {
      this.iframe = UTIL.createElement('iframe', {
        id: 'presentation',
        src: showUrl,
        style: 'width:100%;height:100%;'
      });
      content.appendChild(this.iframe);
    }

    const that = this;
    return ({ op, args = [], fun } = {}) => {
      this.iframe.contentWindow.postMessage(JSON.stringify({ op, args }), showUrl);
      if (fun) that.operationHistoryFun[op] = fun;
    };
  }

  staticPhotoControl(content, images) {
    const len = images.length;
    const load = this._loading();
    if (!(images && len > 0)) return;
    let currentPage = 0;
    let saveImg = null;

    if (this.pptImg) {
      this.pptImg.setAttribute('src', images[0]);
    } else {
      this.pptImg = UTIL.createElement('img', {
        src: images[0],
        id: 'pptImgId',
        // crossOrigin: "Anonymous"
      });
      this.pptImg.onload = () => {
        const imgW = this.pptImg.clientWidth;
        const imgH = this.pptImg.clientHeight;
        const prop = imgW / imgH;
        if (prop !== this.prop) this._resize(prop);
        if (saveImg instanceof Function) saveImg(this.pptImg);
        this.pptImg.setAttribute('style', 'width:100%;height:100%;');
        load.hide();
      };
      content.appendChild(this.pptImg);
    }

    const that = this;

    return ({ op, fun, args = [] }) => {
      switch (op) {
        case 'gotoNextStep':
          changePage({ fun });
          break;
        case 'gotoPreviousStep':
          changePage({ fun, dir: -1 });
          break;
        case 'gotoSlide':
          changePage({ fun, page: args[0] });
          break;
      }
    };

    function changePage({ fun, dir = 1, page } = {}) {
      if (!isNaN(parseInt(page))) {
        currentPage = parseInt(page);
      } else {
        if (dir === -1) {
          currentPage <= 0
            ? currentPage = len - 1
            : currentPage--;
        } else {
          currentPage >= len - 1
            ? currentPage = 0
            : currentPage++;
        }
      }

      let imgUrl = images[currentPage];
      that.pptImg.setAttribute('src', imgUrl);

      if (that.parentUrl) that.sendMsgToParent(JSON.stringify({ slideEvent: "slideChange", slideIndex: currentPage }), that.parentUrl);
      that.currentPageNum = currentPage;
      that.sendPageEnd(that.currentPageNum);
      load.show();
      if (fun) fun();
    }
  }

  sendMsgToParent(msg, url) {
    if (self !== parent) parent.postMessage(msg, url);
    else this.sendMessage(msg);
  }

  _loading() {
    const loading = document.querySelector('#loading');
    if (!loading) return false;
    return {
      show() {
        loading.setAttribute('style', 'display:block');
      },
      hide() {
        loading.setAttribute('style', 'display:none');
      }
    };
  }

  sendPageEnd(num) {
    let event;
    if (num === 0) event = 'firstPage';
    else if (num === this.pageNum - 1) event = 'lastPage';
    if (event) this.sendMsgToParent(JSON.stringify({ slideEvent: event }), this.parentUrl);
  }

  listenMsgCallback(postData) {
    const data = typeof postData === 'string' ? UTIL.parseJson(postData) : postData;
    const { type, result, slideEvent, index, slideIndex } = data;
    if (result === 'success' && this.operationHistoryFun[type]) {
      this.operationHistoryFun[type](data);
    }
    if (slideEvent && this.operation) {
      switch (slideEvent) {
        case 'changeSlice':
          if (parseInt(index) === parseInt(this.currentPageNum)) return;
          this.operation({ op: 'gotoSlide', args: [parseInt(index)] });
          break;
        case 'slideChange':
          this.currentPageNum = slideIndex;
          this.sendPageEnd(this.currentPageNum);
          if (this.parentUrl) this.sendMsgToParent(postData, this.parentUrl);
          break;
        case 'gotoPreviousStep':
          if (this.currentPageNum === 0) return;
          this.operation({ op: slideEvent });
          break;
        case 'gotoNextStep':
          if (this.currentPageNum === this.pageNum - 1) return;
          this.operation({ op: slideEvent });
          break;
      }
      if (this.isRedraw && this.paintbrushCtrl
        && (
          slideEvent === 'changeSlice' ||
          slideEvent === 'slideChange' ||
          (!this.isAnimation &&
            (slideEvent === 'gotoPreviousStep' ||
              slideEvent === 'gotoNextStep')))) {
        const redrawResult = this.paintbrushCtrl.redraw(this.currentPageNum, this.pageType);
        if (!redrawResult) return 'redrawFail';
      }
      return true;
    }
  }

  drawMsgFromSocket(d) {
    const that = this;
    const obj = typeof d === 'string' ? UTIL.parseJson(d) : d;
    if (!obj) {
      console.error('socket返回的ppt相关的json数据有问题');
      return Promise.resolve();
    }
    const { EVENT, data } = obj;
    const { pageId, ID, type, autoId } = data;
    if ((EVENT === 'onSliceStart' || EVENT === 'onSliceOpen' || EVENT === 'onSliceID') && autoId !== undefined) {
      return this._changeBoard(obj);
    }
    if (!this.paintbrushCtrl && this._isRightEvent(EVENT, type)) {
      return this.init(autoId).then(r => {
        if (r === true) draw();
        return;
      });
    }
    draw();
    return Promise.resolve();

    function draw() {
      switch (EVENT) {
        case 'onSliceDraw':
          that._sliceDraw(data);
          break;
        case 'onSliceControl':
          switch (type) {
            case 'switchpage':
              that._switchpage(pageId, autoId);
              break;
            case 'delete':
              that.paintbrushCtrl.delete({ pageId, ID, pageType: that.pageType });
              break;
            case 'alldelete':
              that.paintbrushCtrl.clear(pageId);
              break;
          }
          break;
      }
    }
  }

  _isRightEvent(EVENT, type) {
    return EVENT === 'onSliceStart' || EVENT === 'onSliceOpen' || EVENT === 'onSliceID' || EVENT === 'onSliceDraw' || (EVENT === 'onSliceControl' && (type === 'switchpage' || type === 'delete' || type === 'alldelete'));
  }

  _sliceDraw(data) {
    const { pageId, autoId } = data;
    if (parseInt(autoId) === parseInt(this.currentAutoId) && parseInt(pageId) !== parseInt(this.currentPageNum))
      this.listenMsgCallback({ slideEvent: 'changeSlice', index: pageId });
    this.paintbrushCtrl.drawFromSocket(data, this.pageType);
  }

  _switchpage(pageId, autoId) {
    if (parseInt(autoId) === 0) {
      return this.openWhiteBoard(pageId);
    }
    this.pageType = parseInt(autoId) === 0 ? 'whiteBoard' : 'page';

    if (parseInt(autoId) !== parseInt(this.currentAutoId)) {
      if (this.paintbrushCtrl) this.paintbrushCtrl.clear();
      return;
    }
    if (parseInt(this.currentPageNum) !== parseInt(pageId)) {
      if (this.paintbrushCtrl) this.paintbrushCtrl.clear();
      this.listenMsgCallback({ slideEvent: 'changeSlice', index: pageId });
    }
  }

  _changeBoard({ EVENT, data }) {
    const { pageId, autoId, sessionId, roomId } = data;
    if (EVENT === 'onSliceStart') {
      this.paintbrushCtrl = undefined;
      return this.toInit(autoId, pageId);
    }

    if (EVENT === 'onSliceID') {
      return this._getPlayHistory(sessionId, roomId).then(r => {
        if (r === 0) {
          return this.toInit(autoId, pageId);
        }
        return;
      });
    }

    if (EVENT === 'onSliceOpen') {
      if (parseInt(autoId) === 0) {
        this.openWhiteBoard(pageId);
      } else {
        this.deleteWhiteBoard();
        this.pageType = 'page';
        if (parseInt(this.currentAutoId) !== parseInt(autoId)) {
          if (this.pptImg) this.pptImg.setAttribute('style', '');
          if (this.paintbrushCtrl) {
            this.paintbrushCtrl.autoId = autoId;
          }
          const oldAutoId = this.currentAutoId;
          this.init(autoId).then(r => {
            if (r === true) {
              this.operation({ op: 'gotoSlide', args: [parseInt(pageId)] });
              if (oldAutoId !== undefined && parseInt(oldAutoId) !== 0) this.paintbrushCtrl.clearHistory(oldAutoId);
            }
          });
        }
        if (this.isRedraw) this.paintbrushCtrl.redraw(pageId || 0, this.pageType);
      }
      return Promise.resolve();
    }
  }

  toInit(autoId, pageId) {
    if (parseInt(autoId) === parseInt(this.currentAutoId)) {
      return Promise.resolve();
    }
    if (parseInt(autoId) === 0) {
      this.openWhiteBoard(pageId);
      return Promise.resolve();
    } else {
      return this.init(autoId).then(r => {
        if (r === true) {
          // log('init success......');
          // this.paintbrushCtrl.clearHistory();
          this.paintbrushCtrl.clear();
          this.operation({ op: 'gotoSlide', args: [parseInt(pageId)] });
        }
        return;
      });
    }
  }

  openWhiteBoard(pageId) {
    this.initPaintBrush();
    this.toWhiteBoard();
    this.pageType = 'whiteBoard';
    this.currentPageNum = pageId;
    if (this.isRedraw) this.paintbrushCtrl.redraw(pageId, this.pageType);
  }

  _getPlayHistory(sessionId, roomId) {
    if (!(sessionId && roomId)) return;
    return UTIL.ajax({
      url: '//apichat.polyv.net/front/pptContent',
      data: {
        roomId,
        sessionId,
        time: (new Date()).getTime()
      }
    }).then(result => {
      if (!result) return console.log('请求接口/front/pptContent返回数据为空');
      const { code, data } = result || {};
      if (parseInt(code) !== 200) return console.log('请求接口/front/pptContent失败');
      const d = UTIL.parseJson(data);
      if (!d) return console.log('接口/front/pptContent返回的json数据格式有问题');
      if (!d.length) return 0;

      let max = d[0];
      for (let i = 1, len = d.length; i < len; i++) {
        const v = d[i];
        if (v.time > max.time) {
          const vc = UTIL.parseJson(v.content);
          if (!vc) continue;
          if (this._isRightEvent(vc.EVENT, vc.data.type)) {
            max = v;
          }
        }
      }

      const content = UTIL.parseJson(max.content);
      if (!content) return console.log('json格式有问题');
      const lastData = content.data;

      return this.toInit(lastData.autoId, lastData.pageId).then(() => {
        d.forEach(v => {
          const content = UTIL.parseJson(v.content);
          if (!content) return;
          const { EVENT, data } = content;
          if (EVENT === 'onSliceDraw') this.paintbrushCtrl.saveHistory(data);
          else if (EVENT === 'onSliceControl') {
            const { autoId, pageId, ID, type } = data;
            if (type === 'delete') {
              this.paintbrushCtrl.clearHistory(autoId, pageId, ID);
            } else if (type === 'alldelete') {
              this.paintbrushCtrl.clearHistory(autoId);
            }
          }
        });
        this.paintbrushCtrl.redraw(lastData.pageId, parseInt(lastData.autoId) === 0 ? 'whiteBoard' : 'page');

        return;
      });
    });
  }

  toWhiteBoard() {
    if (this.paintbrushCtrl) {
      this.paintbrushCtrl.canvasDiv.style.background = '#fff';
    }
  }

  deleteWhiteBoard() {
    if (this.paintbrushCtrl) {
      this.paintbrushCtrl.canvasDiv.style.background = 'rgba(0, 0, 0, 0)';
    }
  }

  VODStart(d, callback = () => { }) {
    const data = UTIL.parseJson(d);
    if (!data) {
      return callback('VODStart的json数据格式有问题');
    }
    const { roomId, id, type = 'playback' } = data;
    if (!(roomId && id)) return callback('json数据必须有roomId和id');
    UTIL.ajax({
      url: '//apichat.polyv.net/front/getPPTHistory',
      data: { roomId, id, type, time: (new Date()).getTime() },
    }).then(result => {
      const { code, data } = result;
      if (parseInt(code) !== 200) {
        return callback('请求画笔回看数据失败');
      }
      const paintData = UTIL.parseJson(data);
      if (!paintData) {
        return callback('获取的画笔json数据格式有问题');
      }
      if (!paintData.length) {
        return callback('请求的画笔数据为空');
      }
      this.paintData = paintData.sort((a, b) => a.time > b.time ? 1 : -1);

      this.drawDataKeyUsePage = this.paintData.reduce((obj, v) => {
        const content = UTIL.parseJson(v.content);
        if (!content) callback('获取历史数据时格式有问题：v.content');
        const cd = content.data;
        const pre = parseInt(cd.autoId) === 0 ? 'white' : 'page';
        const key = `${pre}${cd.autoId}${cd.pageId}`;
        obj[key] === undefined
          ? obj[key] = [content]
          : obj[key].push(content);
        return obj;
      }, {});

      return callback(true);
    }).catch(err => {
      return callback(`err:${JSON.stringify(err)},data:${d}`);
    });
  }

  VODPlay(getCurrentTime) {
    // log('VODPlay.....');
    let timeOut;
    let canStart = true;
    if (!(getCurrentTime instanceof Function)) return console.log('VODPlay传入的参数必须为函数');
    const that = this;
    this.isRedraw = false;

    start();
    return {
      stop,
      start() {
        canStart = true;
        start();
      }
    };

    function start() {
      if (!canStart) return;
      timeOut = setTimeout(() => {
        getCurrentTime(currentTimeCallback);
      }, 500);
    }
    function stop() {
      clearTimeout(timeOut);
      canStart = false;
    }
    function currentTimeCallback(d) {
      const data = UTIL.parseJson(d);
      if (!data) return console.log('获取当前播放时间的json字符串有问题');
      const time = data.time;
      that.preTime = time;
      const currentPaint = that._findDataUseTime(time || 0);
      if (!currentPaint) return start();

      const content = currentPaint.content;
      const { pageId, autoId } = UTIL.parseJson(content).data;
      const pageData = that._gethistoryData(pageId, autoId);
      that.toInit(autoId, pageId).then(() => {
        that.paintbrushCtrl.clear();
        pageData.forEach(v => {
          if (v.data.timeStamp <= time) {
            that.drawMsgFromSocket(v);
          }
        });
        start();
      });
    }
  }

  _findDataUseTime(time) {
    if (!this.paintData) return null;
    return find(this.paintData);
    function find(arr) {
      const len = arr.length;
      const con = parseInt(len / 2);
      const content = UTIL.parseJson(arr[con].content);
      const timeStamp = content.timeStamp === undefined ? content.data.timeStamp : content.timeStamp;

      if (con === len - 1) {
        if (time > timeStamp) {
          return arr[con];
        }
        return len === 1 ? null : find([arr[0]]);
      }

      if (parseInt(time) === parseInt(timeStamp)) return arr[con];
      if (time < timeStamp) {
        return find(arr.slice(0, con));
      } else {
        return find(arr.slice(con, arr.length));
      }
    }
  }

  pptSeek(d) {
    // log(d);
  }

  _gethistoryData(pageId, autoId) {
    const preStr = parseInt(autoId) === 0 ? 'white' : 'page';
    return this.drawDataKeyUsePage[`${preStr}${autoId}${pageId}`];
  }
}

typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = PPTH5 :
typeof define === 'function' && define.amd ? define(PPTH5) : 
(global.PPTH5 = PPTH5);

export default PPTH5;
